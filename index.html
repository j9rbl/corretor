<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taquear Imagem</title>
    <link rel="stylesheet" href="https://unpkg.com/cropperjs/dist/cropper.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c2c2c;
            color: #fff;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #3c3c3c;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #imageContainer {
            width: 100%;
            max-width: 600px;
            height: 400px;
            border: 2px dashed #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #fff;
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
        }

        #image {
            max-width: 100%;
            max-height: 100%;
            display: none;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 200px;
            background-color: #4c4c4c;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            margin-bottom: 20px;
        }

        button,
        input[type=range],
        input[type=number] {
            margin-top: 10px;
            padding: 10px;
            font-size: 16px;
            background-color: #5c5c5c;
            border: none;
            border-radius: 4px;
            color: #fff;
        }

        button:hover,
        input[type=range]:hover,
        input[type=number]:hover {
            background-color: #6c6c6c;
        }

        .hidden {
            display: none;
        }

        #zoomContainer {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            transform-origin: center;
            transition: transform 0.2s ease;
        }

        .filter-container {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-top: 10px;
        }

        #removeBgButton {
            background-color: #007BFF;
            color: #fff;
        }

        #removeBgButton:hover {
            background-color: #0056b3;
        }

        .palette {
            display: flex;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .colorBox {
            width: 20px;
            height: 20px;
            margin: 2px;
            cursor: pointer;
            border: 1px solid #000;
        }

        #menuInferior {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }

        #pixelationSection {
            display: flex;
            align-items: flex-start;
            width: 100%;
        }

        #container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #sideMenu {
            display: flex;
            flex-direction: column;
            margin-left: 10px;
            background-color: #4c4c4c;
            padding: 70px;
            border-radius: 22px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
            max-width: 200px;
            min-width: 200px;
            position: fixed;
            right: 0;
            top: 0;
            height: 100%;
            overflow-y: auto;
        }
    </style>
</head>

<body>
 <div id="loginContainer" class="container">
        <h2>Login</h2>
        <input type="email" id="email" placeholder="Email">
        <input type="password" id="password" placeholder="Password">
        <button id="loginButton">Login</button>
    </div>
    <div class="container">
        <input type="file" id="imageInput" accept="image/*">
        <div id="imageContainer">
            <div id="zoomContainer">
                <img id="image" alt="Selected Image">
            </div>
        </div>
        <div class="sidebar">
            <button id="cropButton">Cortar Imagem</button>
            <div id="cropOptions" class="hidden">
                <label for="widthInput">Width:</label>
                <input type="number" id="widthInput" value="150">
                <label for="heightInput">Height:</label>
                <input type="number" id="heightInput" value="200">
                <button id="resizeButton">Resize</button>
            </div>
            <div id="filterOptions" class="hidden filter-container">
                <label for="brightnessInput">Brilho:</label>
                <input type="range" id="brightnessInput" min="0" max="2" step="0.1" value="1">
                <label for="contrastInput">Contraste:</label>
                <input type="range" id="contrastInput" min="0" max="2" step="0.1" value="1">
                <label for="sharpnessInput">Nitidez:</label>
                <input type="range" id="sharpnessInput" min="0" max="2" step="0.1" value="0">
                <label for="saturationInput">Saturação:</label>
                <input type="range" id="saturationInput" min="0" max="2" step="0.1" value="1">
                <label for="zoomInput">Zoom:</label>
                <input type="range" id="zoomInput" min="1" max="5" step="0.1" value="1.5">
                <button id="removeBgButton">Remover Fundo</button>
                <button id="pixelateButton">Taquear Imagem</button>
                <button id="reduceCopyButton">Reduzir e Copiar</button>
            </div>
        </div>
    </div>

    <div id="pixelationSection" class="hidden">
        <div id="container">
            <div id="pixelContainer">
                <canvas id="pixelCanvas"></canvas>
            </div>
        </div>
        <div id="sideMenu">
            <div class="controls">
                <label for="skinToneCount">Tons de Pele:</label>
                <input type="range" id="skinToneCount" min="0" max="20" value="10" oninput="updateColors()">
                <div id="skinTonePalette" class="palette"></div>
            </div>
            <div class="controls">
                <label for="diffusionPercentage"></label>
                <input type="radio" name="ditheringType" value="diffusion" onchange="updateColors()"> Difusão
                <input type="range" id="diffusionPercentage" min="0" max="100" value="50" oninput="updateColors()">
            </div>
            <div class="controls">
                <label for="standardPercentage"></label>
                <input type="radio" name="ditheringType" value="standard" onchange="updateColors()"> Padrão
                <input type="range" id="standardPercentage" min="0" max="100" value="50" oninput="updateColors()">
            </div>
            <div class="controls">
                <label for="blueNoisePercentage"></label>
                <input type="radio" name="ditheringType" value="blueNoise" onchange="updateColors()"> Ruído Azul
                <input type="range" id="blueNoisePercentage" min="0" max="100" value="50" oninput="updateColors()">
            </div>
            <div class="controls">
                <label for="selectedColors">Cores do Projeto</label>
                <div id="selectedColors" class="palette"></div>
                <button id="clearColorsBtn" onclick="clearColors()">Limpar Cores</button>
            </div>
            <div class="controls">
                <label for="allColors">Tabela de Cores</label>
                <div id="allColors" class="palette"></div>
                <button id="autoColorButton">Auto Colorize</button>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/cropperjs/dist/cropper.js"></script>
    <script>
 <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js"></script>
    <script>
        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCItHl6wfx7ZR7jtz2t9Em2xEPRssMGhnQ",
  authDomain: "taqueador-49a9d.firebaseapp.com",
  projectId: "taqueador-49a9d",
  storageBucket: "taqueador-49a9d.appspot.com",
  messagingSenderId: "338642082771",
  appId: "1:338642082771:web:dda5623273e851326ced26",
  measurementId: "G-T54KW0FNF2"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);

        const auth = firebase.auth();

        // Handle login
        document.getElementById('loginButton').addEventListener('click', function() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;

            auth.signInWithEmailAndPassword(email, password)
                .then((userCredential) => {
                    document.getElementById('loginContainer').classList.add('hidden');
                    document.getElementById('appContainer').classList.remove('hidden');
                })
                .catch((error) => {
                    alert('Login failed: ' + error.message);
                });
        });

        // Handle authentication state changes
        auth.onAuthStateChanged((user) => {
            if (user) {
                document.getElementById('loginContainer').classList.add('hidden');
                document.getElementById('appContainer').classList.remove('hidden');
            } else {
                document.getElementById('loginContainer').classList.remove('hidden');
                document.getElementById('appContainer').classList.add('hidden');
            }
        });
        document.getElementById('imageInput').addEventListener('change', handleImageUpload);
        document.getElementById('cropButton').addEventListener('click', showCropOptions);
        document.getElementById('resizeButton').addEventListener('click', resizeImage);
        document.getElementById('brightnessInput').addEventListener('input', applyFilters);
        document.getElementById('contrastInput').addEventListener('input', applyFilters);
        document.getElementById('sharpnessInput').addEventListener('input', applyFilters);
        document.getElementById('saturationInput').addEventListener('input', applyFilters);
        document.getElementById('zoomInput').addEventListener('input', applyZoom);
        document.getElementById('removeBgButton').addEventListener('click', removeBackground);
        document.getElementById('pixelateButton').addEventListener('click', showPixelationSection);
        document.getElementById('reduceCopyButton').addEventListener('click', reduceAndCopyPixelArt);
        document.getElementById('autoColorButton').addEventListener('click', autoColorize);

        let imageWithoutBackground = null;
        let selectedImage;
        let cropper;
        let resizedCanvas;
        let originalImageData;

        function handleImageUpload(event) {
            const reader = new FileReader();
            reader.onload = function (e) {
                selectedImage = new Image();
                selectedImage.src = e.target.result;
                selectedImage.onload = function () {
                    const imageContainer = document.getElementById('imageContainer');
                    const imageElement = document.getElementById('image');
                    imageElement.src = selectedImage.src;
                    imageElement.style.display = 'block';
                    imageContainer.style.border = 'none';
                    if (cropper) {
                        cropper.destroy();
                    }
                    cropper = new Cropper(imageElement, {
                        aspectRatio: NaN,
                        viewMode: 1,
                    });
                };
            };
            reader.readAsDataURL(event.target.files[0]);
        }

        function showCropOptions() {
            document.getElementById('cropOptions').classList.remove('hidden');
            document.getElementById('cropButton').classList.add('hidden');
        }

        function resizeImage() {
            const width = parseInt(document.getElementById('widthInput').value, 10);
            const height = parseInt(document.getElementById('heightInput').value, 10);
            if (cropper) {
                const canvas = cropper.getCroppedCanvas();
                resizedCanvas = document.createElement('canvas');
                resizedCanvas.width = width;
                resizedCanvas.height = height;

                const ctx = resizedCanvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;

                ctx.drawImage(canvas, 0, 0, width, height);

                originalImageData = ctx.getImageData(0, 0, width, height);
                const resizedImage = resizedCanvas.toDataURL('image/jpeg', 0.9);
                const imageElement = document.getElementById('image');
                imageElement.src = resizedImage;
                cropper.destroy();
                imageElement.style.display = 'block';
                document.getElementById('cropOptions').classList.add('hidden');
                document.getElementById('filterOptions').classList.remove('hidden');
            }
        }

        function applyFilters() {
            if (!resizedCanvas) return;

            const brightness = parseFloat(document.getElementById('brightnessInput').value);
            const contrast = parseFloat(document.getElementById('contrastInput').value);
            const saturation = parseFloat(document.getElementById('saturationInput').value);
            const sharpness = parseFloat(document.getElementById('sharpnessInput').value);

            const ctx = resizedCanvas.getContext('2d');
            ctx.putImageData(originalImageData, 0, 0);
            let imageData = ctx.getImageData(0, 0, resizedCanvas.width, resizedCanvas.height);
            let data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = ((data[i] - 128) * contrast + 128) * brightness;
                data[i + 1] = ((data[i + 1] - 128) * contrast + 128) * brightness;
                data[i + 2] = ((data[i + 2] - 128) * contrast + 128) * brightness;
            }

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const avg = (r + g + b) / 3;
                data[i] = avg + (r - avg) * saturation;
                data[i + 1] = avg + (g - avg) * saturation;
                data[i + 2] = avg + (b - avg) * saturation;
            }

            ctx.putImageData(imageData, 0, 0);

            if (sharpness !== 0) {
                applySharpness(ctx, resizedCanvas.width, resizedCanvas.height, sharpness);
            }

            const updatedImage = resizedCanvas.toDataURL('image/jpeg', 0.9);
            document.getElementById('image').src = updatedImage;

            if (imageWithoutBackground) {
                const canvas = document.createElement('canvas');
                canvas.width = resizedCanvas.width;
                canvas.height = resizedCanvas.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(resizedCanvas, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;

                for (let i = 0; i < data.length; i += 4) {
                    if (imageWithoutBackground.data[i + 3] === 0) {
                        data[i + 3] = 0;
                    }
                }

                ctx.putImageData(imageData, 0, 0);
                document.getElementById('image').src = canvas.toDataURL('image/png');
            }
        }

        function applySharpness(ctx, width, height, sharpness) {
            let imageData = ctx.getImageData(0, 0, width, height);
            let data = imageData.data;

            const sharpenMatrix = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];
            const side = Math.round(Math.sqrt(sharpenMatrix.length));
            const halfSide = Math.floor(side / 2);
            const src = ctx.getImageData(0, 0, width, height).data;
            const output = ctx.createImageData(width, height);
            const dst = output.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0;
                    for (let cy = 0; cy < side; cy++) {
                        for (let cx = 0; cx < side; cx++) {
                            const scy = y + cy - halfSide;
                            const scx = x + cx - halfSide;
                            if (scy >= 0 && scy < height && scx >= 0 && scx < width) {
                                const srcOffset = (scy * width + scx) * 4;
                                const wt = sharpenMatrix[cy * side + cx];
                                r += src[srcOffset] * wt;
                                g += src[srcOffset + 1] * wt;
                                b += src[srcOffset + 2] * wt;
                            }
                        }
                    }
                    const dstOffset = (y * width + x) * 4;
                    dst[dstOffset] = r * sharpness + src[dstOffset] * (1 - sharpness);
                    dst[dstOffset + 1] = g * sharpness + src[dstOffset + 1] * (1 - sharpness);
                    dst[dstOffset + 2] = b * sharpness + src[dstOffset + 2] * (1 - sharpness);
                    dst[dstOffset + 3] = src[dstOffset + 3];
                }
            }

            ctx.putImageData(output, 0, 0);
        }

        async function removeBackground() {
            const apiKey = 'TkMFTCFPPJY63uKdgZRpTaXY';
            const imageElement = document.getElementById('image');
            const formData = new FormData();
            formData.append('image_file', dataURLtoBlob(imageElement.src));
            formData.append('size', 'auto');

            try {
                const response = await fetch('https://api.remove.bg/v1.0/removebg', {
                    method: 'POST',
                    headers: {
                        'X-Api-Key': apiKey,
                    },
                    body: formData,
                });

                if (!response.ok) {
                    throw new Error('Remove.bg API request failed.');
                }

                const resultBlob = await response.blob();
                const resultUrl = URL.createObjectURL(resultBlob);
                imageElement.src = resultUrl;
                imageWithoutBackground = await blobToImageData(resultBlob);
                applyFilters();
            } catch (error) {
                console.error('Error removing background:', error);
            }
        }

        function dataURLtoBlob(dataURL) {
            const byteString = atob(dataURL.split(',')[1]);
            const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeString });
        }

        async function blobToImageData(blob) {
            const img = await createImageBitmap(blob);
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            return ctx.getImageData(0, 0, canvas.width, canvas.height);
        }

        function applyZoom() {
            const zoomLevel = parseFloat(document.getElementById('zoomInput').value);
            document.getElementById('zoomContainer').style.transform = `scale(${zoomLevel})`;
        }

        function showPixelationSection() {
            document.getElementById('pixelationSection').classList.remove('hidden');
            generatePixelArtFromExistingImage();
        }

        function generatePixelArtFromExistingImage() {
            const img = new Image();
            img.src = document.getElementById('image').src;
            img.onload = function () {
                createPixelArt(img);
            };
        }

        let currentImageData = null;
        let selectedColors = ["#FFFFFF", "#000000", "#2A2A2A", "#ffdcbf", "#fbb697", "#f9957b", "#d07a5f", "#9e4a32"];
        const skinTones = [
            "#FFD4A3", "#FDB1A3", "#FBA87D", "#F9967B", "#D0785F",
            "#B86851", "#9E4A32", "#85492B", "#763726", "#431E09"
        ];

        const fixedColorTable = [
            "#ffffff", "#000000", "#00fffc", "#00adff", "#0048ff", "#002499", "#037aff", "#ffa5e0", "#aae2ff", "#ffc9ec", "#ff4fcb", "#ff0480", "#ff00cc", "#c000ff", "#6a00a1", "#fffdb3", "#fff600", "#ffa200", "#ff7e00", "#ff0000", "#ab0000", "#9cff00", "#00ffb4", "#00b300", "#037603", "#00520c", "#485a00", "#1f370f", "#c7c7c7", "#939393", "#464646", "#2a2a2a", "#ffdcbf", "#fdbdab", "#fbb697", "#f9957b", "#d07a5f", "#b86851", "#9e4a32", "#85492b", "#763726", "#431e09", "#fde5d0", "#740012", "#d1786a", "#a1008c", "#ffba00", "#921d00", "#c5a5ff", "#c36a00", "#00b5bc", "#F1D600", "#6a3319", "#ad6628", "#fe324a", "#bbe04c", "#c3ffb5", "#83ffdb", "#dadada", "#ff7e7e", "#edad75"
        ];

        let isDragging = false;
        let startX, startY, initialScrollLeft, initialScrollTop, scale = 1.0;
        let zoomClicks = 0;
        const maxZoomClicks = 8;

        function generatePixelArt() {
            const imageUpload = document.getElementById('imageUpload').files[0];
            if (imageUpload) {
                const reader = new FileReader();
                reader.onload = function (event) {
                    const img = new Image();
                    img.onload = function () {
                        createPixelArt(img);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(imageUpload);
            }
        }

        function createPixelArt(img) {
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            const width = img.width;
            const height = img.height;
            canvas.width = width * 5;
            canvas.height = height * 5;
            ctx.drawImage(img, 0, 0, width, height);
            const imageData = ctx.getImageData(0, 0, width, height);
            currentImageData = imageData;
            drawPixelatedImage(imageData);
            updateColors();
            document.getElementById('pixelCanvas').style.display = 'block';

            const canvasContainer = document.getElementById('pixelContainer');
            canvasContainer.addEventListener('mousedown', startDrag);
            canvasContainer.addEventListener('mousemove', drag);
            canvasContainer.addEventListener('mouseup', endDrag);
            canvasContainer.addEventListener('mouseleave', endDrag);
            canvasContainer.addEventListener('wheel', zoom);
        }

        function startDrag(event) {
            isDragging = true;
            startX = event.clientX;
            startY = event.clientY;
            const canvasContainer = document.getElementById('pixelContainer');
            initialScrollLeft = canvasContainer.scrollLeft;
            initialScrollTop = canvasContainer.scrollTop;
            canvasContainer.style.cursor = 'grabbing';
        }

        function drag(event) {
            if (isDragging) {
                const canvasContainer = document.getElementById('pixelContainer');
                const dx = event.clientX - startX;
                const dy = event.clientY - startY;
                canvasContainer.scrollLeft = initialScrollLeft - dx;
                canvasContainer.scrollTop = initialScrollTop - dy;
            }
        }

        function endDrag() {
            isDragging = false;
            const canvasContainer = document.getElementById('pixelContainer');
            canvasContainer.style.cursor = 'grab';
        }

        function zoom(event) {
            event.preventDefault();
            const canvas = document.getElementById('pixelCanvas');
            const canvasContainer = document.getElementById('pixelContainer');
            const rect = canvas.getBoundingClientRect();
            const offsetX = event.clientX - rect.left + canvasContainer.scrollLeft;
            const offsetY = event.clientY - rect.top + canvasContainer.scrollTop;

            let delta = event.deltaY > 0 ? -0.1 : 0.1;
            if (event.deltaY < 0) {
                zoomClicks++;
                scale = Math.min(scale + delta, 10);
            }
            if (event.deltaY > 0 && zoomClicks > -8) {
                zoomClicks--;
                scale = Math.max(scale + delta, 0.1);
            }

            const prevScrollLeft = canvasContainer.scrollLeft;
            const prevScrollTop = canvasContainer.scrollTop;
            const prevScale = scale - delta;

            const newScrollLeft = (offsetX + prevScrollLeft) * (scale / prevScale) - offsetX;
            const newScrollTop = (offsetY + prevScrollTop) * (scale / prevScale) - offsetY;

            canvas.style.transformOrigin = 'center center';
            canvas.style.transform = `scale(${scale})`;

            canvasContainer.scrollLeft = newScrollLeft;
            canvasContainer.scrollTop = newScrollTop;
        }

        function updateColors() {
            if (!currentImageData) return;
            const skinToneCount = parseInt(document.getElementById('skinToneCount').value);
            const skinToneTable = getSkinToneTable(skinTones, skinToneCount);
            const colorTable = selectedColors;
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            const imageData = new ImageData(
                new Uint8ClampedArray(currentImageData.data),
                currentImageData.width,
                currentImageData.height
            );

            const ditheringTypeElement = document.querySelector('input[name="ditheringType"]:checked');
            if (!ditheringTypeElement) return;

            const ditheringType = ditheringTypeElement.value;
            const intensityElement = document.getElementById(`${ditheringType}Percentage`);
            if (!intensityElement) return;

            const intensity = parseInt(intensityElement.value) / 100;

            if (ditheringType === 'diffusion') {
                applyDiffusionDithering(imageData, imageData.width, imageData.height, skinToneTable.concat(colorTable), intensity);
            } else if (ditheringType === 'standard') {
                applyStandardDithering(imageData, imageData.width, imageData.height, skinToneTable.concat(colorTable), intensity);
            } else if (ditheringType === 'blueNoise') {
                applyBlueNoiseDithering(imageData, imageData.width, imageData.height, skinToneTable.concat(colorTable), intensity);
            }

            ensureColorsInTable(imageData, fixedColorTable);
            drawPixelatedImage(imageData);
            updateColorPalette(skinToneTable, colorTable);
        }

        function getSkinToneTable(colors, maxCount) {
            const usage = countColorUsage(currentImageData, colors);
            const sortedColors = Object.keys(usage).sort((a, b) => usage[b] - usage[a]);
            const selectedColors = [];
            const step = Math.max(1, Math.floor(sortedColors.length / maxCount));
            for (let i = 0; i < sortedColors.length; i += step) {
                if (selectedColors.length < maxCount) {
                    selectedColors.push(sortedColors[i]);
                }
            }
            return selectedColors;
        }

        function countColorUsage(imageData, colors) {
            const colorUsage = {};
            colors.forEach(color => colorUsage[color] = 0);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b] = [data[i], data[i + 1], data[i + 2]];
                const hexColor = rgbToHex(r, g, b);
                if (colorUsage.hasOwnProperty(hexColor)) {
                    colorUsage[hexColor]++;
                }
            }
            return colorUsage;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function ensureColorsInTable(imageData, colorTable) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b] = [data[i], data[i + 1], data[i + 2]];
                const closestColor = findClosestColor(r, g, b, colorTable);
                data[i] = closestColor[0];
                data[i + 1] = closestColor[1];
                data[i + 2] = closestColor[2];
            }
        }

        function findClosestColor(r, g, b, colorTable) {
            let minDistance = Infinity;
            let closestColor = null;
            colorTable.forEach(hex => {
                const [red, green, blue] = hexToRgb(hex);
                const distance = Math.sqrt((r - red) ** 2 + (g - green) ** 2 + (b - blue) ** 2);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = [red, green, blue];
                }
            });
            return closestColor;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = (bigint & 255);
            return [r, g, b];
        }

        function applyDiffusionDithering(imageData, width, height, colorValues, intensity) {
            const data = imageData.data;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const oldColor = [data[i], data[i + 1], data[i + 2]];
                    const newColor = findClosestColor(...oldColor, colorValues);
                    const error = oldColor.map((c, index) => c - newColor[index]);
                    data[i] = newColor[0];
                    data[i + 1] = newColor[1];
                    data[i + 2] = newColor[2];
                    distributeError(data, width, height, x, y, error, intensity);
                }
            }
        }

        function applyStandardDithering(imageData, width, height, colorValues, intensity) {
            const data = imageData.data;
            const bayerMatrix = [
                [0, 2],
                [3, 1]
            ];
            const matrixSize = 2;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const oldColor = [data[i], data[i + 1], data[i + 2]];
                    const threshold = (bayerMatrix[y % matrixSize][x % matrixSize] / 4) * 255 * intensity;

                    const newColor = oldColor.map(c => clamp(c + (threshold - 128) * 0.2));

                    const finalColor = findClosestColor(newColor[0], newColor[1], newColor[2], colorValues);

                    data[i] = finalColor[0];
                    data[i + 1] = finalColor[1];
                    data[i + 2] = finalColor[2];
                }
            }
        }

        function clamp(value) {
            return Math.max(0, Math.min(255, value));
        }

        function applyBlueNoiseDithering(imageData, width, height, colorValues, intensity) {
            const data = imageData.data;
            const blueNoise = generateBlueNoise(width, height);
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const noiseValue = blueNoise[y * width + x] * intensity;
                    const oldColor = [data[i] + noiseValue, data[i + 1] + noiseValue, data[i + 2] + noiseValue];
                    const newColor = findClosestColor(...oldColor, colorValues);
                    data[i] = newColor[0];
                    data[i + 1] = newColor[1];
                    data[i + 2] = newColor[2];
                }
            }
        }

        function generateBlueNoise(width, height) {
            const noise = new Float32Array(width * height);
            for (let i = 0; i < noise.length; i++) {
                noise[i] = (Math.random() - 0.5) * 255;
            }
            return noise;
        }

        function distributeError(data, width, height, x, y, error, factor) {
            distribute(data, width, height, x + 1, y, error, 7 / 16 * factor);
            distribute(data, width, height, x - 1, y + 1, error, 3 / 16 * factor);
            distribute(data, width, height, x, y + 1, error, 5 / 16 * factor);
            distribute(data, width, height, x + 1, y + 1, error, 1 / 16 * factor);
        }

        function distribute(data, width, height, x, y, error, factor) {
            if (x < 0 || x >= width || y < 0 || y >= height) return;
            const i = (y * width + x) * 4;
            data[i] = clamp(data[i] + error[0] * factor);
            data[i + 1] = clamp(data[i + 1] + error[1] * factor);
            data[i + 2] = clamp(data[i + 2] + error[2] * factor);
        }

        function updateColorPalette(skinToneTable, colorTable) {
            const skinTonePalette = document.getElementById('skinTonePalette');
            skinTonePalette.innerHTML = '';
            skinToneTable.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'colorBox';
                colorBox.style.backgroundColor = color;
                colorBox.addEventListener('click', () => {
                    if (!selectedColors.includes(color)) {
                        selectedColors.push(color);
                        updateColors();
                    }
                });
                skinTonePalette.appendChild(colorBox);
            });

            const selectedColorsContainer = document.getElementById('selectedColors');
            selectedColorsContainer.innerHTML = '';
            colorTable.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'colorBox';
                colorBox.style.backgroundColor = color;
                colorBox.addEventListener('click', () => {
                    selectedColors = selectedColors.filter(c => c !== color);
                    updateColors();
                });
                selectedColorsContainer.appendChild(colorBox);
            });

            const allColorsContainer = document.getElementById('allColors');
            allColorsContainer.innerHTML = '';
            fixedColorTable.forEach(color => {
                const colorBox = document.createElement('div');
                colorBox.className = 'colorBox';
                colorBox.style.backgroundColor = color;
                colorBox.addEventListener('click', () => {
                    if (!selectedColors.includes(color)) {
                        selectedColors.push(color);
                        updateColors();
                    }
                });
                allColorsContainer.appendChild(colorBox);
            });
        }

        function drawPixelatedImage(imageData) {
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            const width = imageData.width;
            const height = imageData.height;
            const pixelSize = 5;
            canvas.width = width * pixelSize;
            canvas.height = height * pixelSize;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    const r = imageData.data[i];
                    const g = imageData.data[i + 1];
                    const b = imageData.data[i + 2];
                    const a = imageData.data[i + 3] / 255;

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
                    ctx.fillRect(x * pixelSize, y * pixelSize, pixelSize, pixelSize);
                }
            }
        }

        function reduceAndCopyPixelArt() {
            const pixelCanvas = document.getElementById('pixelCanvas');
            const reducedCanvas = document.createElement('canvas');
            reducedCanvas.width = pixelCanvas.width / 5;
            reducedCanvas.height = pixelCanvas.height / 5;
            const ctx = reducedCanvas.getContext('2d');

            ctx.imageSmoothingEnabled = false;
            ctx.fillStyle = '#963295';
            ctx.fillRect(0, 0, reducedCanvas.width, reducedCanvas.height);

            ctx.drawImage(pixelCanvas, 0, 0, reducedCanvas.width, reducedCanvas.height);
            reducedCanvas.toBlob(blob => {
                const item = new ClipboardItem({ "image/png": blob });
                navigator.clipboard.write([item]).then(() => {
                    flashButton();
                });
            });
        }

        function flashButton() {
            const button = document.getElementById('reduceCopyButton');
            button.style.backgroundColor = 'green';
            setTimeout(() => {
                button.style.backgroundColor = '';
            }, 500);
        }

        function clearColors() {
            selectedColors = [];
            updateColorPalette([], selectedColors);
            updateColors();
        }

        async function autoColorize() {
            document.getElementById('skinToneCount').value = 0;
            updateColors();

            selectedColors = [];
            updateColorPalette([], selectedColors);

            if (!currentImageData) return;
            const canvas = document.getElementById('pixelCanvas');
            const ctx = canvas.getContext('2d');
            const imageData = new ImageData(
                new Uint8ClampedArray(currentImageData.data),
                currentImageData.width,
                currentImageData.height
            );

            ensureColorsInTable(imageData, fixedColorTable);
            selectedColors = extractUsedColors(imageData);
            selectedColors = reduceColorPalette(selectedColors, 20);

            mergeSimilarColors(imageData);
            cleanUpImage(imageData);

            drawPixelatedImage(imageData);

            const usedColors = extractUsedColors(imageData);
            selectedColors = [...new Set(usedColors)];
            updateColorPalette([], selectedColors);
            updateColors();
        }

        function extractUsedColors(imageData) {
            const colors = [];
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const [r, g, b] = [data[i], data[i + 1], data[i + 2]];
                const hexColor = rgbToHex(r, g, b);
                if (!colors.includes(hexColor)) {
                    colors.push(hexColor);
                }
            }
            return colors;
        }

        function reduceColorPalette(colors, maxColors) {
            while (colors.length > maxColors) {
                let minDistance = Infinity;
                let colorPair = [null, null];
                for (let i = 0; i < colors.length; i++) {
                    for (let j = i + 1; j < colors.length; j++) {
                        const distance = colorDistance(hexToRgb(colors[i]), hexToRgb(colors[j]));
                        if (distance < minDistance) {
                            minDistance = distance;
                            colorPair = [i, j];
                        }
                    }
                }
                const newColor = averageColor(hexToRgb(colors[colorPair[0]]), hexToRgb(colors[colorPair[1]]));
                colors[colorPair[0]] = rgbToHex(newColor[0], newColor[1], newColor[2]);
                colors.splice(colorPair[1], 1);
            }
            return colors;
        }

        function averageColor(color1, color2) {
            return [
                Math.round((color1[0] + color2[0]) / 2),
                Math.round((color1[1] + color2[1]) / 2),
                Math.round((color1[2] + color2[2]) / 2)
            ];
        }

      function mergeSimilarColors(imageData) {
    const data = imageData.data;
    const combinedColors = fixedColorTable.concat(skinTones);

    for (let i = 0; i < data.length; i += 4) {
        const [r, g, b] = [data[i], data[i + 1], data[i + 2]];
        const closestColor = findClosestColor(r, g, b, combinedColors);

        if (closestColor) {
            data[i] = closestColor[0];
            data[i + 1] = closestColor[1];
            data[i + 2] = closestColor[2];
        }
    }
}


        function cleanUpImage(imageData) {
    const data = imageData.data;
    const width = imageData.width;
    const height = imageData.height;

    for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
            const i = (y * width + x) * 4;
            const color = [data[i], data[i + 1], data[i + 2]];

            const neighbors = getNeighbors(data, width, height, x, y);
            const predominantColor = findPredominantColor(neighbors);

            if (colorDistance(color, predominantColor) > 1) {
                data[i] = predominantColor[0];
                data[i + 1] = predominantColor[1];
                data[i + 2] = predominantColor[2];
            }
        }
    }
}

        function getNeighbors(data, width, height, x, y) {
    const neighbors = [];
    const directions = [
        [-1, -1], [-1, 0], [-1, 1],
        [0, -1], [0, 1],
        [1, -1], [1, 0], [1, 1]
    ];

    directions.forEach(dir => {
        const nx = x + dir[0];
        const ny = y + dir[1];
        const ni = (ny * width + nx) * 4;
        neighbors.push([data[ni], data[ni + 1], data[ni + 2]]);
    });

    return neighbors;
}

function findPredominantColor(neighbors) {
    const colorCounts = {};
    neighbors.forEach(color => {
        const key = color.join(',');
        if (colorCounts[key]) {
            colorCounts[key]++;
        } else {
            colorCounts[key] = 1;
        }
    });

    let predominantColor = null;
    let maxCount = 0;
    Object.keys(colorCounts).forEach(key => {
        if (colorCounts[key] > maxCount) {
            maxCount = colorCounts[key];
            predominantColor = key.split(',').map(Number);
        }
    });

    return predominantColor;
}

        function colorDistance(color1, color2) {
            return Math.sqrt(
                (color1[0] - color2[0]) ** 2 +
                (color1[1] - color2[1]) ** 2 +
                (color1[2] - color2[2]) ** 2
            );
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
        }

        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = (bigint & 255);
            return [r, g, b];
        }
    </script>

    <script>
       document.addEventListener('contextmenu', function (e) {
            e.preventDefault();
            alert('O botão direito do mouse está desativado.');
        });

        document.addEventListener('keydown', function (e) {
            if ((e.ctrlKey && e.shiftKey && e.keyCode == 'I'.charCodeAt(0)) ||
                (e.ctrlKey && e.shiftKey && e.keyCode == 'J'.charCodeAt(0)) ||
                (e.ctrlKey && e.keyCode == 'U'.charCodeAt(0)) ||
                (e.ctrlKey && e.shiftKey && e.keyCode == 'C'.charCodeAt(0))
            ) {
                e.preventDefault();
                alert('A inspeção de elementos está desativada.');
            }
        });

        document.addEventListener('keydown', function (e) {
            if (e.key === 's' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                alert('Salvar a página está desativado.');
            }
        });

        document.addEventListener('keydown', function (e) {
            if ((e.ctrlKey && e.key === 'p') || (e.metaKey && e.key === 'p')) {
                e.preventDefault();
                alert('Imprimir página está desativado.');
            }
        });
 if (window.location.protocol === 'file:') {
            document.addEventListener('DOMContentLoaded', function() {
                // Desativa todo o conteúdo da página
                document.body.innerHTML = '<h1>Esta página não pode ser executada localmente.</h1>';
                document.body.style.color = 'red';
                document.body.style.textAlign = 'center';
                document.body.style.paddingTop = '20%';
                document.body.style.backgroundColor = '#000';
            });
        }

    </script>
</body>

</html>
